{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Python v R: Variables as Pointers"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "R and Python have a lot of similarities, but there are some important differences. The biggest, discussed below, is the idea of \"variables as pointers\". But before we dive into that, a few smaller differences that tend to get people tripped up: \n",
    "\n",
    "* **The analogue of `data.frames` and `vectors` are in `numpy` and `pandas` libraries, not Python itself**: When you watch basic Python tutorials, you'll find yourself wondering where the vectors and data.frames are -- don't worry! They exist, but they're in distinct libraries called `numpy` and `pandas`, so basic Python tutorials won't talk about them. \n",
    "* **Periods are operators in Python**: In R, it's common to use periods in variable names (like: `my.list`). There are many syntax differences between R and Python, but for some reason people really struggle with this one -- periods are an operator in Python, so don't use them in names! The convention is to use underscores, like: `my_list`.\n",
    "* **In Python you always count starting at 0, not 1** For example, to get the first entry in a list, you type `my_list[0]`, not `my_list[1]`. `my_list[1]` will get you the *second* entry in the list. \n",
    "\n",
    "## Variables as Pointers \n",
    "\n",
    "Now the big conceptual difference between Python and R: variables as pointers. \n",
    "\n",
    "Say you make a new vector as follows:\n",
    "\n",
    "``my.list <- list(1,2,3)``\n",
    "\n",
    "In R, there's no difference between a variable (``my.list``) and the object associated with it (the list 1, 2, 3). But this is actually a slight of hand used by R to hide something fundamental about how computers work, and it does not happen in Python.\n",
    "\n",
    "In Python, variables and the objects they point two actually live in two different places in your computer. As a result, in Python it's best to think of variables as *pointing* to the objects they're associated with, rather than *being* those objects. Personally, I've always liked the analogy of your computer being a big warehouse, and variables are just the entries in the inventory book used by the warehouse manager: the variable tells you how to find the thing you want, but it is not the thing itself. \n",
    "\n",
    "So when you create a new list, Python puts that list somewhere in memory, kind of like how you might put something big on a shelf in a warehouse. The variable associated with that list (say, ``my.list``) actually just stores the *location* of the shelf where that list was placed. And because this behavior is normal in most languages, you may not see it emphasized in Python tutorials written by programmers not coming from R.\n",
    "\n",
    "The reason this matters is that it's possible for multiple variables to be pointed at the same object. As a result, changes made to an object though one variable will impact what you get if you call the other variables pointed at that object! For example:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[1, 2, 3, 4]"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Make a new list\n",
    "x = [1, 2, 3]\n",
    "# Make new var Y, and assign it x. In R this would make a copy.\n",
    "y = x\n",
    "# Add to the end of the string\n",
    "x.append(4)\n",
    "# We see this new addition is now at end of x\n",
    "x"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[1, 2, 3]"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# But look! It's also at the end of y!\n",
    "# That's because both variables are actually pointing to the same object in memory (\"in the warehouse\"), \n",
    "# so when you appended something to x, you changed the underlying object. And \n",
    "# since y was also pointed at that same object, when you next call y, it \n",
    "# \"sees\" those changes to the underlying list. \n",
    "y"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "If what you want to do is make a *copy* of x, you use the `copy()` command. This makes an entirely new list (a new object that looks the same as the old one, but which can be put on a different shelf) so that changes to `x` won't impact the list associated with `y`. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[1, 2, 3]"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "x = [1, 2, 3]\n",
    "y = x\n",
    "y_copy = x.copy()\n",
    "x.append(4)\n",
    "y_copy"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Last, if you want to see if two variables point to the same thing, you can use the `is` operator, which tests whether two variables are pointed at the same place in memory / same shelf:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "x is y"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "x is y_copy"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Note that `is` is not the same as `==`. `==` asks if the *entries* in the lists the two variables point at have the same values, while `is` asks if the two variables are pointing to *the exact same object*. So: "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 24,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "x = [1, 2, 3]\n",
    "y = x.copy()\n",
    "# Since we made a copy, x and y aren't pointing to the same thing...\n",
    "x is y"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 27,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# But as x and y both point to lists with the entries 1, 2, 3, they point to lists that are equal in terms of their entries\n",
    "x == y"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Mutable versus Immutable Types\n",
    "\n",
    "Now a wrinkle. \n",
    "\n",
    "Certain data types in Python are called \"immutable\". That means an object, once created, can't be actually modified. As a result, if you want to do something that looks like modifying the object, Python has to actually create *an entirely new object* and lives in a new location. \n",
    "\n",
    "Strings, for example, are \"immutable\". So if we create a string, then try and modify it, what we're actually doing is creating a new string that has the features we want. \n",
    "\n",
    "To illustrate, we can use the `id()` function. Every object in Python has a unique `id()`, and so when two variables point to the same object, then `id()` of those variables will also return the same thing:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "4442514928"
      ]
     },
     "execution_count": 41,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Make x a simple string, then make y point to that same string\n",
    "x = \"my string\"\n",
    "y = x\n",
    "\n",
    "id(x)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "4442514928"
      ]
     },
     "execution_count": 42,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "id(y)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As we can see, x and y point to the same object. But now let's see what happens if we modify that string:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'MY STRING'"
      ]
     },
     "execution_count": 43,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "x = x.upper()\n",
    "x"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "4442614704"
      ]
     },
     "execution_count": 44,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "id(x)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As we can see, `x` now has a new value of ID. That's because calling `x` actually created a new string that was the uppercase version of \"my string\", then made `x` point to that new object. \n",
    "\n",
    "But what happened to `y`?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'my string'"
      ]
     },
     "execution_count": 45,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "y"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "4442514928"
      ]
     },
     "execution_count": 46,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "id(y)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As we can see, `y` is still pointing at the old string and still has the same `id()`. \n",
    "\n",
    "This illustrates one of the naunces of Python: **if you modify a mutable object, that change will propagate to all variables that point at said object. But if you modify an immutable object, a new object will actually be created, so that change will not be accessible to variables pointing at the old object.**"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## What's mutable, and what's immutable?\n",
    "\n",
    "Here's quick list of data types you're likely to encounter that are *immutable*:\n",
    "\n",
    "- int\n",
    "- float\n",
    "- decimal\n",
    "- complex\n",
    "- bool\n",
    "- string\n",
    "- tuple\n",
    "\n",
    "And here are common datatypes that are *mutable*: \n",
    "\n",
    "- lists\n",
    "- sets\n",
    "- dictionaries\n",
    "- user defined objects\n",
    "- numpy arrays\n",
    "\n",
    "How do you remember this? It is *nearly*  accurate to say that **anything that is a collection of other objects is mutable, except `tuples`**. There are some weird datatypes that are also collections that are immutable (*frozensets*, which as the name implies are \"frozen\" and thus can't be changed), but you're unlikely to ever use those, and if you do, it's because you know you want something immutable. \n",
    "\n",
    "\n",
    "\n",
    "## Confused?\n",
    "\n",
    "Yeah, that's reasonable. This is really tricky. Honestly, you probably won't feel like you \"get\" this until you play around with it a lot (as we'll do in the exercises below), but [here's another great discussion of this](https://www.pythonforthelab.com/blog/mutable-and-immutable-objects/) which I would recommend if you want to see this all explained in a slightly different way. \n",
    "\n",
    "## Exercises\n",
    "\n",
    "[Variables as Pointers Exercises](exercises/exercise_variables_as_pointers.ipynb)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
